// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGeolocation = `-- name: CreateGeolocation :one
INSERT INTO
    geolocations (
        degree,
        latitude,
        longitude,
        speed,
        vehicle_id,
        variant_id,
        "timestamp"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) RETURNING degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
`

type CreateGeolocationParams struct {
	Degree    float32
	Latitude  float32
	Longitude float32
	Speed     float32
	VehicleID int64
	VariantID int64
	Timestamp pgtype.Timestamptz
}

func (q *Queries) CreateGeolocation(ctx context.Context, arg CreateGeolocationParams) (Geolocation, error) {
	row := q.db.QueryRow(ctx, createGeolocation,
		arg.Degree,
		arg.Latitude,
		arg.Longitude,
		arg.Speed,
		arg.VehicleID,
		arg.VariantID,
		arg.Timestamp,
	)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Latitude,
		&i.Longitude,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const createOrGetVehicle = `-- name: CreateOrGetVehicle :one
INSERT INTO
    vehicles(license_plate)
VALUES
    ($1) ON CONFLICT (license_plate) DO NOTHING RETURNING id, license_plate
`

func (q *Queries) CreateOrGetVehicle(ctx context.Context, licensePlate string) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createOrGetVehicle, licensePlate)
	var i Vehicle
	err := row.Scan(&i.ID, &i.LicensePlate)
	return i, err
}

const createOrUpdateRoute = `-- name: CreateOrUpdateRoute :one
INSERT INTO
    routes (
        number,
        name,
        ebms_id
    )
VALUES
    ($1, $2, $3) ON CONFLICT (ebms_id) DO
UPDATE
SET
    number = EXCLUDED.number,
    name = EXCLUDED.name RETURNING id, number, name, ebms_id, active
`

type CreateOrUpdateRouteParams struct {
	Number string
	Name   string
	EbmsID pgtype.Int8
}

func (q *Queries) CreateOrUpdateRoute(ctx context.Context, arg CreateOrUpdateRouteParams) (Route, error) {
	row := q.db.QueryRow(ctx, createOrUpdateRoute, arg.Number, arg.Name, arg.EbmsID)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Name,
		&i.EbmsID,
		&i.Active,
	)
	return i, err
}

const createOrUpdateVariant = `-- name: CreateOrUpdateVariant :one
INSERT INTO
    variants (
        name,
        ebms_id,
        is_outbound,
        route_id
    )
VALUES
    ($1, $2, $3, $4) ON CONFLICT (is_outbound, route_id) DO
UPDATE
SET
    name = EXCLUDED.name RETURNING id, name, ebms_id, is_outbound, route_id
`

type CreateOrUpdateVariantParams struct {
	Name       string
	EbmsID     pgtype.Int8
	IsOutbound bool
	RouteID    int64
}

func (q *Queries) CreateOrUpdateVariant(ctx context.Context, arg CreateOrUpdateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, createOrUpdateVariant,
		arg.Name,
		arg.EbmsID,
		arg.IsOutbound,
		arg.RouteID,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
	)
	return i, err
}

const getRouteByEbmsID = `-- name: GetRouteByEbmsID :one
SELECT
    id, number, name, ebms_id, active
FROM
    routes
WHERE
    ebms_id = $1
LIMIT
    1
`

func (q *Queries) GetRouteByEbmsID(ctx context.Context, ebmsID pgtype.Int8) (Route, error) {
	row := q.db.QueryRow(ctx, getRouteByEbmsID, ebmsID)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Name,
		&i.EbmsID,
		&i.Active,
	)
	return i, err
}

const getRouteByVariantID = `-- name: GetRouteByVariantID :one
SELECT
    degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
FROM
    geolocations
WHERE
    variant_id = $1
LIMIT
    1
`

func (q *Queries) GetRouteByVariantID(ctx context.Context, variantID int64) (Geolocation, error) {
	row := q.db.QueryRow(ctx, getRouteByVariantID, variantID)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Latitude,
		&i.Longitude,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const getVariantByRouteIDAndOutbound = `-- name: GetVariantByRouteIDAndOutbound :one
SELECT
    id, name, ebms_id, is_outbound, route_id
FROM
    variants
WHERE
    route_id = $1
    AND is_outbound = $2
LIMIT
    1
`

type GetVariantByRouteIDAndOutboundParams struct {
	RouteID    int64
	IsOutbound bool
}

func (q *Queries) GetVariantByRouteIDAndOutbound(ctx context.Context, arg GetVariantByRouteIDAndOutboundParams) (Variant, error) {
	row := q.db.QueryRow(ctx, getVariantByRouteIDAndOutbound, arg.RouteID, arg.IsOutbound)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
	)
	return i, err
}
